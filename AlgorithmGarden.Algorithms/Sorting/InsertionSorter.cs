using System;
using System.Collections.Generic;
using System.Text;

namespace AlgorithmGarden.Algorithms.Sorting
{
    /*
     往一组数据中插入数据，如何保持有序呢？
     遍历数组，找到应该插入的位置

    已排序区间：初始已排序区间只有1个元素，是数组中的第1个元素
    未排序区间：
    核心思想：在未排序区间取出元素，把它插入到已排序区间的某个位置，已排序区间的元素一直是排序的，重复下去，直到未排序区间没有元素

     4  56132
     45 6132
     456  132
     1456  32
     13456  2
     123456

     当需要把未排序区间的元素a取出来，拿a与已排序区间的元素依次比较大小，找到合适的位置插入，再将插入点后元素的顺序往后移动一位
     查找插入点的方法有时从头部开始，有时从尾部开始
     */

    public class InsertionSorterHelper
    {
        public void InsertionSort(int[] a, int n)
        {
            if (n <= 1) return;

            //4  56132
            //45 6132
            for (int i=1;i<n;i++) //未排序区间,第一个元素不需要动
            {
                //5
                int value = a[i]; //i=1
                int j = i - 1; //j=0
                for(; j>=0; --j) //已排序区间，遍历次数和未排序区间的元素位置有关系
                {
                    //每次把未排序区间的第一个元素取出来
                    //a[j]就是从未排序区间取出来这个元素的前面一个元素
                    //从已经排序区间的尾部开始比较
                    if(a[j] > value)
                    {
                        a[j + 1] = a[j];
                    }
                    else //插入的值比把当前值小，那位置就找到j=0
                    {
                        break;
                    }
                }

                a[j + 1] = value;
            }
        }
    }

    /*
     运行并不需要额外的存储空间，空间复杂度O(1),原地排序算法
     是稳定排序算法

     如果排序的数据有序，并不需要搬任何数据
     从尾到头在有序数组里查找插入位置，每次只比较一个数据，时间复杂度O(1)

     如果排序的数据是倒序的，每次插入新的数据，都需要移动大量的数据，时间复杂度O(n^2)
     */

    /*
     选择排序
     从未排序区间找到最小的元素放到已排序区间的末尾

    456321
    1 56324 最后一个与第一个交换了位置
    12 6354
    123 654
    1234 56
    12345 6
    123456

    空间复杂度O(1)，原地排序法
    最好和最坏情况复杂度O(n^2)
    是不稳定排序，每次要找剩余未排序元素中的最小值，并且和前面的元素位置交换，破坏了稳定性
     */

    /*
     为什么插入排序比冒泡排序受欢迎？

     冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度，插入排序也是一样。

     从代码实现来看，冒泡排序3个赋值操作，插入排序1个赋值操作
     虽然冒泡排序和插入排序的时间复杂度都是O(n^2)，如果数据多还是有区别的
     */

    /*
     插入排序的优化是：希尔排序
     */

    /*
     以上的算法是通过数组来实现的。可以通过链表来实现吗？
     用链表实现，一般考虑开遍链表的节点的位置，不改变链表节点的value值
     如果用链表做，比较次数与数组一致，但交换操作更复杂
     插入排序比较次数一致，不需要后移操作，找到位置后直接插入，但排序完成后需要倒置链表
     选择排序比较次数一致，交换操作同样麻烦

     冒泡排序的时间复杂度系数会稍大，插入排序会稍小，选择排序无明显变化
     */
}

using System;
using System.Collections.Generic;
using System.Text;

namespace AlgorithmGarden.Algorithms.Sorting
{
    /*
     排序数组中下标从p到r
     在p和r之间任意选择一点pivot分区点
     遍历p到r,将小于pivot的放到左边，将大于pivot的放到右边
     这样就被分成了3组：[p, q-1] [q][q+1, r]
     分治递归

     公式：quick_sort(p,r) = quick_sort(p,q-1) + quick_sort(q+1,r)
     终止条件：p>=r
     */

    /*
     72186354
     把最后一个元素4作为pivot
     现在要做的就是把比4小的放在左边，比4大的放在右边
     需要两个游标，i一开始放在0位置，j放在1位置一直游到n-2的位置，即在当前情况下游动到倒数第二个位置
     即i放在了7的前面一个位置，j放在了7这个位置
     现在要比较了
     把j所在的位置上的7和pivot 4进行比较，7比4大，7保持不动，把j向后移动一位，游标到2
     2比4小，把游标i放到7，意思是说找到比4小的元素了，游标i可以移动了
     把7和2交换位置，就是小的在左边，大的在右边
     27186354，i指向2，j指向7
     现在i指向小元素区间的第一个位置(或者理解为小元素区间的最后一个位置)，j指向大元素区间的第一个位置
     再把j向后移动一位到了1
     1比4小，又找到比4的元素了，i可以向前移动一位到7
     i指向的7和j指向的1交换位置
     21786354，i指向1，指向7
     把j再向后移动一位指向8
     8比4大，什么都不做
     21786354，i指向1，j指向8
     把j向后移动一位指向6
     6比4大，什么都不做
     21786354，i指向1，j指向6
     把j向后移动一位指向3
     3比4小，又找到了比4小的，i需要向后一位，i的新位置用来存放刚发现的比4小的元素
     把7和3交换位置
     21386754，i指向3，j指向7
     j向后移动一位，指向5
     5比4大，什么都不做
     21386754,i指向3， j最终指向大元素的最后一个位置5
     把大元素8675都向后移动一位腾出位置给4
     21348654

     以上，随便挑了一个数，然后通过两个游标，一个游标i指向小元素的最后一位，一个游标j用来游动最终来到大元素的最后一个位置，最后把所有大元素向右移动一位，pivot放在小元素区间的最后一位，然后左边部分又一块连续的小元素，右边部分有一块连续的大元素，这就完成了partition
     */
}

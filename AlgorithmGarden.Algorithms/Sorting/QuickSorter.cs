using System;
using System.Collections.Generic;
using System.Text;

namespace AlgorithmGarden.Algorithms.Sorting
{
    /*
     72186354
     把最后一个元素4作为pivot
     现在要做的就是把比4小的放在左边，比4大的放在右边
     需要两个游标，i一开始放在0位置，j放在1位置一直游到n-2的位置，即在当前情况下游动到倒数第二个位置
     即i放在了7的前面一个位置，j放在了7这个位置
     现在要比较了
     把j所在的位置上的7和pivot 4进行比较，7比4大，7保持不动，把j向后移动一位，游标到2
     2比4小，把游标i放到7，意思是说找到比4小的元素了，游标i可以移动了
     把7和2交换位置，就是小的在左边，大的在右边
     27186354，i指向2，j指向7
     现在i指向小元素区间的第一个位置(或者理解为小元素区间的最后一个位置)，j指向大元素区间的第一个位置
     再把j向后移动一位到了1
     1比4小，又找到比4的元素了，i可以向前移动一位到7
     i指向的7和j指向的1交换位置
     21786354，i指向1，指向7
     把j再向后移动一位指向8
     8比4大，什么都不做
     21786354，i指向1，j指向8
     把j向后移动一位指向6
     6比4大，什么都不做
     21786354，i指向1，j指向6
     把j向后移动一位指向3
     3比4小，又找到了比4小的，i需要向后一位，i的新位置用来存放刚发现的比4小的元素
     把7和3交换位置
     21386754，i指向3，j指向7
     j向后移动一位，指向5
     5比4大，什么都不做
     21386754,i指向3， j最终指向大元素的最后一个位置5
     把大元素8675都向后移动一位腾出位置给4
     21348654

     以上，随便挑了一个数，然后通过两个游标，一个游标i指向小元素的最后一位，一个游标j用来游动最终来到大元素的最后一个位置，最后把所有大元素向右移动一位，pivot放在小元素区间的最后一位，然后左边部分又一块连续的小元素，右边部分有一块连续的大元素，这就完成了partition
     */

    /*
    数组中下标从p到r
    在p到r之间选择任意一点作为pivot分区点
    遍历p到r之间的数据
    将小于pivot的放左边，将大于pivot的放右边，pivot在中间，假设pivot所在的位置是q
    p到q-1都是小于pivot，q+1到r之间大于pivot
    在p到q-1和q+1到r之间进行递归

    quick_sort(p...r) = quick_sort(p...q-1) + quick_sort(q+1...r);
    p>=r就是终止条件

    //A表示数组，n表示数组的长度
    quick_sort(A, n){
        quick_sort_c(A, 0, n-1);
    }

    //p为起始点，r为终点
    quick_sort_c(A, p, r){
        if(p>=r) return;

        //分区得到pivot,随机选择一个元素作为pivot
        //一般情况下选择p到r之间的最后一个元素
        q = partion(A, p, r);
        quick_sort_c(A, p, q-1);
        quick_sort_c(A, q+1, r);
    }

    partition函数如何写呢？

    原来的数组 A[p...r] 8 10 2 3 6 1 5
    把5作为pivot
    把小于5的找出来，申请一个x数组，把2 3 1分别放入x数组
    把大于5的找出来，申请一个y数组，把8 10 6分别放入y数组
    把x和y数组中的元素分别拷贝到原来的数组A[p...r]中，把5放在中间

    注意这里，当申请x和y数组的时候，用到了额外的内存空间
    所以这样的partition就不是原地排序算法了

    如果希望是原地排序，即空间复杂度是O(1)呢？

    partion(A, p, r){
        pivot := A[r]; //把最后一个元素作为pivot
        i := p;//游标i的位置暂时指向数组的第一个位置p
        for j := p to r-1 do { //游标j的位置一直移动，从数组的起始位置p开始,一直到r-1,因为r位置上的元素已经作为pivot了
            if(A[j] < pivot){
                swap A[i] with A[j]
                i := i+1;
            }
        }
        swap A[i] with A[r]
        return i;
    }

    以上，通过位置交换保证在原地操作。
    这有点像输入的插入操作：在数组的某个位置插入元素，需要搬移数据，非常耗时。提高效率的办法就是在原地操作。

    快速排序后元素的相对位置会发生改变，所以快速排序不是稳定的排序算法。
    */

    /*
    归并排序，先处理子问题，然后再合并。处理顺序是由下到上。是稳定的排序，时间复杂度是O(nlogn)，是非原地排序算法，因为合并函数无法在原地执行。

    快速排序，先分区再处理子问题。处理顺序是由上到下。是一种原地、不稳定的排序算法。
    
    快速排序的最好时间复杂度。如果每次分区操作把数组分成大小接近相等的两个小区间，那快排的时间复杂度和归并相同，是O(nlogn)。但实际情况是很难实现的，比如下面：

    快速排序的最坏时间复杂度。
    1 3 5 6 8
    每次选择最后一个元素作为pivot
    每次分区得到的两个区间都是不均等的
    需要进行n次分区操作，每次分区要扫描n/2个元素
    这时的时间复杂度是O(n^2)

    快速排序的平均复杂度。
    假设每次分区都将区间分成大小为9：1的两个区间，也是O(nlogn)
    */

    /*
    O(n)时间复杂度找到无序数组中的第K大元素
    4 2 5 12 3 中第三大元素是4
    抽象成数组A[0...n-1]
    把A[n-1]作为pivot
    分区为：A[0...n-1], A[p], A[p+1...n-1]
    把3作为pivot
    把i指向-1，j指向0，4>3，位置不懂，i还是指向-1
    4 2 5 12 3 i指向-1，j指向0
    j指向位置1,指向2,2<3，4和2交换位置
    2 4 5 12 3 i指向0，j指向1
    j指向位置2，指向5，5>3，不动
    2 4 5 12 3 i指向0，j指向2
    j指向位置3，指向12，12>3,不动
    2 4 5 12 3, i指向0， j指向3
    把4 5 12向后移动一位，把3放在1号位
    2 3 4 5 12 p=1
    再回顾问的问题：找出第三大元素4，按照索引来讲是k=3
    注意p是索引位置，k是从1开始的自然数
    如果k>p+1,说明第K大元素出现在A[p+1...n-1]区间
    如果k<p+1,说明第K大元素出现在A[0...n-1]区间
    如果k=p+1,说明第K大元素就是A[p+1]
    显然，第一次遍历了n个元素，所以这里的最好情况时间复杂度是O(n)
    */
}

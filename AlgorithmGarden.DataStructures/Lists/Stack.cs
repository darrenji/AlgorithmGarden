using System;
using System.Collections.Generic;
using System.Text;

namespace AlgorithmGarden.DataStructures.Lists
{
    /// <summary>
    /// 顺序栈
    /// </summary>
    public class ArrayStack
    {
        //空间复杂度是指除了原本的算法占有的空间之外，算法运行时所需要的额外的空间
        private string[] items;//空间复杂度为O(1) 
        private int currentCount;
        private int length;

        public ArrayStack(int length)
        {
            this.items = new string[length];
            this.length = length;
            this.currentCount = 0;
        }

        //不管时入栈还是出栈只涉及栈顶的操作，时间复杂度时O(1)
        public bool Push(string item)
        {
            //随着currentCount的增大可能会超出数组的最大长度，所以要考虑超出最大长度这个边界
            if(currentCount==length) //因为currentCount是从0开始的，所以总比长度小1。如果等于数组长度就表示超出了。利用索引和长度的关系，这个条件找得很妙
            {
                return false;
            }

            //插入的本质就是放在数组的某个位置
            this.items[currentCount] = item;

            ++currentCount;
            return true;
        }

        public string Pop()
        {
            //一直出栈会面临栈为空的情况哦
            if (currentCount == 0) return null;

            //这里出栈用到的临时变量也不会占有太大的空间，空间复杂度时O(1)
            string temp = this.items[currentCount - 1];
            --currentCount;
            return temp;
        }
    }

    //以上栈的大小是固定的
    //如果动态扩容呢？
    //可能想到链式栈，但链式栈有指针，所以占用的空间比较大
    //还可以是，当数组空间不够时，重新申请一块更大的内存，将原来的数组数据拷贝过去

    //这种动态扩容的栈的时间复杂度时多少呢？
    //出栈的时候不涉及内存的申请和数据的拷贝，所以出栈的时间复杂度是O(1)
    //入栈的时候，当空间不够，需要重新申请内存拷贝数据，这时的时间复杂度是O(n)
    //对于入栈，更准确地讲，最好情况时间复杂度是O(1)，最坏情况时间复杂度是O(n)
    //入栈的平均复杂度是多少呢？--摊还分析法

    //来看动态扩容的过程
    //如果一个栈超出k个的时候进行扩容
    //当k+1个元素想入栈
    //申请2倍大小的内存
    //把原先栈的K个元素搬到新的栈，这里的时间复杂度是O(n)
    //后面还有k-1次入栈，每次入栈的时间复杂度是O(1)
    //好了，我们发现只有在扩容的那次数据搬运工作时间复杂度是O(n)，其后的时间复杂度一直是O(1)
    //把K个数据搬运均摊到后面的k-1次入栈操作，就相当于每个入栈操作额外加了一次搬运工作，时间复杂度是O(1)
    //也得出了这样一个结论：均摊时间复杂度一般都等于最好情况时间复杂度


    //栈有哪些应用呢？

    //函数放在栈内
    //操作系统为每个线程执行的函数分配一块独立的内存空间
    //每个函数以"栈帧"的形式存在于这个内存空间
    //假设有一个外部函数和内部函数，首先执行外部函数，外部函数所有的变量都存在于外部函数的"栈帧"内，当执行到内部函数的时候，内部函数的所有变量也存在于内部函数的"栈帧"内，内部函数执行完，内部函数的"栈帧"出栈
    //所以啊，函数的执行就是"栈帧"的入栈出栈过程


    //编译器利用入栈出栈解析表达式求值
    //假设有这样一个表达式：3+5*8-6
    //编译器需要栈的帮忙，把数字放在数字栈，把操作符放在操作符栈
    //好了，从左到右开始
    //把3放入数字栈
    //把+放入操作符栈
    //把5放入数字栈
    //*的优先级比+高，把*放入操作符栈
    //把8放入数字栈
    //*出栈进行乘法运算数字栈变为40
    //+出栈进行加法运算数字栈变为43
    //6入数字栈
    //-入操作符栈
    //-出栈进行减法运算，数字栈变为37


    //栈在括号匹配中的应用
    //(),[],{},{[{}]}合法，[{()}([])]合法
    //{[}()]不合法，[({)]不合法
    //从左到右依次扫描字符串
    //当扫描到左括号的时候，左括号入栈
    //当扫描到右括号的时候，左括号出栈与右括号匹配
    //当所有扫描结束，如果栈为空，说明字符串为合法格式；否则，说明有未匹配的，就不合法


    //浏览器的前进、后退
    //比如先后查看了a,b,c三个页面
    //a,b,c先后进x栈,当前在c页面上
    //如何从c后退到b呢？让c从x栈出栈再放入y栈
    //如何从b后退到a呢？让b从x栈出栈再放入y栈
    //如果又想看b呢？让b从y栈出栈再入x栈
    //此时如果想看一个新的页面d
    //d入x栈，清空y栈
}

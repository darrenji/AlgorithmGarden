using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AlgorithmGarden.Maths
{
    /// <summary>
    /// 十进制、二进制转换
    /// </summary>
    public class BinaryHelpers
    {
        public static string ConvertIntToBinary(int n)
        {
            return Convert.ToString(n, 2);
        }

        public static int ConvertBinaryToInt(string b)
        {
            //把字符串转换成数组
            var reverseBits = b.Reverse().ToArray();
            var result = 0;
            for (var i = 0; i < reverseBits.Count(); i++)
            {
                var currentItem = reverseBits[i];
                if (currentItem == '1')
                {
                    var currentResult = (int)System.Math.Pow(2, i);
                    result += currentResult;
                }
            }
            return result;
        }
    }

    /*
 10进制
 1256
 1*10^3 + 2*10^2 + 5*10^1 + 6*10^0
 10就是10进制的基数

 2进制
 看作以2为基数
 110101
 1*2^5 + 1*2^4 + 0*2^3 + 1*2^2 + 0*2^1 + 1*2^0=32+16+0+4+0+1=53
 */

    /*
电路只有断开和接通两个状态
电路接通的状态用1表示，断开的状态用0表示
逻辑运算中的真就时1，逻辑运算中的假就时0。那么逻辑运算中的额或、与都可以用1或0表示。

二进制位操作，也叫位运算
直接对内存中的二进制位进行操作

向左移位，向右移位
向左移动就是在最后加一个0，比如110101(53)向左移动一位就是1101010
这里要注意数字溢出了，二进制的位数超出了系统指定的位数。
或者可以理解为向左移动一位，最后面用0填上
1101010换算成十进制就时106，正好时53的两倍。
【结论】二进制向左移动一位，数字翻倍

向右移位，零填充到最前面
110101变成了011010，换算成10进制就时26，也就时53除以2的整数商
【结论】二进制向右移动一位，就是数字除以2并求整数商的操作
*/

    /*
     十进制转换成二进制
     先考虑二进制转换成十进制
     二进制的数量级从右到左就是2^0 2^1 2^2,每一个数量级上的可能值就时0或1
     所以，二进制转换成十进制就时不断乘2的过程，十进制转换成二进制就是不断除2的过程
     把783转换成二进制
     不断除以2
     把每次得到的余数写下来
     1111000011
     如果是Int16表示16位二进制，在前面补零，补足到16位
     如果Int32表示32位二进制，在前面补零，补到32位
     如何把负数的十进制抓换成二进制呢？
     先得到正数的二进制，在把所有位前后颠倒，再加1
     如何知道一个二进制是正数还是负数呢？
     需要看数据类型。如果是Int16，第一个是0就是正数，第一个是1那就是负数。
     对于UInt16根据第一个数无法判定是正数还是负数
     */

    /*
     二进制转换成十进制
     过程和十进制转换成二进制相反
     如果把负数二进制转换十进制呢？
     先把二进制的前后位置颠倒，得到十进制，再加1，再得到负数的十进制
     */

    /*
     A|B
     只要一个是1，结果就是1
     */

    /*
     A&B
     只有两个都是1，结果就是1
     */

    /*
     A^B
     1^1 结果是0
     0^1 1^0结果却是1
     */

    /*
     ~A 0变成1 1变成0
     */

    /*
     circular left shift
     所有向左移动一位，把第一位放到最后面一位
     cirular right shift
     所有向右移动一位，把最后一位放到最前面一位
     */

    /*
     十六进制 
     0 1 2 3 4 5 6 7 8 9
     A B C D E F
     */

    /*
     符号位
     有符号二进制数中的最高位，用来表示负数。
     计算机的CPU的运算器只实现了加法器，没有实现减法器
     如何实现减法呢？
     3+(-2)
     二进制数有符号数signed和无符号数unsigned
     如果是有符号数，最高位就是符号位，0表示正数，1表示负数
     比如有符号位二进制10100010，最高位1，是负数
     如果是无符号数，那么最高位就不是符号位，而是二进制数字的一部分
     */

    /*
     溢出
     晶体管的大小和数量是有极限的
     无论何种数据类型都有上限和下限
     int类型，32位，最大值就是2^31-1,因为最高位是符号位
     超出上限overflow
     超出下限underflow

     n位数字的最大的正值2^n-1 01111111111...111
     加一
     1000000000...000 是-2^n-1
     也就是，上溢出加一，变成了最小的数值
     如果从一条直线上来看的话，每溢出加一，都回来一段-2^n-1~2^n-1
     计算机的溢出相当于取模，取模的除数就是数据类型的上限减去下限再加一
     */

    /*
     原码
     二进制的原始表示
     对于有符号的二进制来说，原码的最高位是符号为
     2的原码是：000...010
     -2的原码是：100...010

     是否可以使用负数的原码来进行减法计算呢？
     答案是不可以。
     比如2，000...010
     -2, 100...010
     3，000...011
     3   000...011
     -2  100...010
     3+(-2)二进制加法满2就进位：100...101,就是-5，而正确的结果是1，所以不能用二进制原码来进行减法计算
     也就是负数的原码不适合做减法计算
     那减法是如何做到的呢？
     
     */

    /*
    二进制减法
    计算机内部不直接对二进制原码进行保存和操作，而是对二进制的补码进行操作
    原码、反码、补码
    计算机为什么需要补码呢？
    --这和现实世界一样。比如时间，时间都是递进的，有很多时间，人们想出了对时间的度量，比如1秒、1分钟、1小时、一天、1星期。度量表示一段范围，与之相关的概念就是模和余数。拿星期来讲，7就是模，星期一就是余数。又比如，在mysql的索引中，根据索引找到值，索引就是模。在计算机内部也是一样，数的范围很大，不可能每个数对应一块内存空间。所以啊，模是人们拿来用有限应对较大的数或者无限的解决办法。

     模
     可以把模看作是杯子里最高水位上面的那个单位，一旦达到模，就意味着已经溢出了。
     时钟的模式12，范围式0-11，让我们可以显式看到模。而在计算机中模式不存在的，看不到的，没有内存空间的。

     假设有8位，那么最大值就是：
     8位的最大值：11111111，对应的十进制数是2^n-1=2^8-1
     然后再加1，变成了100000000，由于只有8位，最高位丢掉，变成00000000，加1从最大变成最小，模就是2^8。

     拿时钟来举例。
     比如想把时钟从10点调到6点。一种是手动把时钟从10点往前拨4个小时，拨回到6点，但实际情况是时钟往一个方向旋转，我们可以让时钟顺时针再走8个小时，也会到6点。这里的4和8就是互为补数。10-4=10-4+12=10+8，把减法等价成了加法，也就是减去一个数，相当于加上这个数的补数。

     比如：i-j
     根据上面时钟的例子,假设是有符号二进制
     i-j = i-j+模=i-j+(2^(n-1)-1+1)=i+[2^(n-1)-1-j]+1
     实际上，2^(n-1)-1-j就是j的反码
     来证明反码的过程：假设j是2，2^(n-1)-1意味着除了符号位，其它位置上都是1
     也就是现在要证明：2^(n-1)-1-2
     2^(n-1)-1的原码：11...111
             2的原码：00...010
                    ----------
                     11...101,这里的结果就是2的按位取反
     所以，i-j=i+j的反码+1=i+j的补码，这条公式就式计算机内部经常使用的公式。从原码到补码是可以相互转换的。

     例子：
     有符号二进制原码：10100010对应的十进制数是多少？
     思路：通过反码、补码再转换成十进制
     原码是：10100010
     保持符号位不动，取反：11011101
     加1：11011110
     2+4+8+16+64=94
     因为符号位是1，表示负数，所以结果是：-94
     */
}
